name: UI Tests

on:
  pull_request:
    branches: [main]

permissions:
  contents: write
  pull-requests: write

jobs:
  ui-tests:
    name: Playwright UI Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    defaults:
      run:
        working-directory: web-app
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: web-app/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install chromium --with-deps

      - name: Run Playwright tests
        id: tests
        continue-on-error: true
        run: npx playwright test

      # Upload the full HTML report (includes embedded screenshots and traces)
      - name: Upload Playwright HTML report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: web-app/playwright-report/
          retention-days: 30

      # Upload raw screenshots as a separate artifact
      - name: Upload screenshots artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-screenshots
          path: web-app/test-results/**/*.png
          if-no-files-found: ignore
          retention-days: 30

      # Push screenshots to an orphan branch so they have public raw URLs,
      # then post a PR comment with the images embedded inline.
      - name: Post screenshots to PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          TEST_OUTCOME: ${{ steps.tests.outcome }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.issue.number;
            const runId = context.runId;
            const sha = context.sha.slice(0, 8);
            const screenshotBranch = '_ci-screenshots';
            const screenshotDir = `runs/${runId}-${sha}`;

            // ── Read Playwright JSON results for per-test status ──
            // The JSON reporter writes a results.json with nested suites/specs.
            // We flatten it into a map: "dir-name-project" → "passed"|"failed"
            const testStatusMap = {};
            try {
              const raw = fs.readFileSync('web-app/test-results/results.json', 'utf8');
              const report = JSON.parse(raw);

              function walkSuites(suites, parentTitles = []) {
                for (const suite of suites) {
                  const titles = [...parentTitles, suite.title];
                  if (suite.specs) {
                    for (const spec of suite.specs) {
                      for (const test of spec.tests || []) {
                        // Build the directory name Playwright uses for test artifacts:
                        // "Suite-title-Test-title-projectName" with spaces → hyphens
                        const fullTitle = [...titles.slice(1), spec.title]
                          .join('-')
                          .replace(/\s+/g, '-');
                        const dirKey = `${fullTitle}-${test.projectName}`;
                        const passed = test.status === 'expected';
                        testStatusMap[dirKey] = passed ? 'passed' : 'failed';
                      }
                    }
                  }
                  if (suite.suites) {
                    walkSuites(suite.suites, titles);
                  }
                }
              }
              walkSuites(report.suites || []);
            } catch (e) {
              core.info(`Could not read results.json: ${e.message}`);
            }

            // ── Find all PNG screenshots ──
            let pngs = [];
            try {
              const out = execSync(
                'find web-app/test-results -name "*.png" -type f | sort',
                { encoding: 'utf8' }
              );
              pngs = out.trim().split('\n').filter(Boolean);
            } catch {
              pngs = [];
            }

            const testStatus = process.env.TEST_OUTCOME;
            const statusIcon = testStatus === 'success' ? ':white_check_mark:' : ':x:';
            const runUrl = `${context.serverUrl}/${owner}/${repo}/actions/runs/${runId}`;

            let body = `## ${statusIcon} UI Test Screenshots\n\n`;
            body += `**Status**: ${testStatus === 'success' ? 'All tests passed' : 'Some tests failed'}  \n`;
            body += `**Commit**: \`${context.sha.slice(0, 8)}\` | [Workflow run](${runUrl})\n\n`;

            if (pngs.length > 0) {
              // ── Push screenshots to the orphan branch via Git Trees API ──

              // 1. Check if the branch exists; if not, create an orphan root
              let baseTreeSha;
              let parentCommitSha;
              try {
                const { data: ref } = await github.rest.git.getRef({
                  owner, repo,
                  ref: `heads/${screenshotBranch}`,
                });
                parentCommitSha = ref.object.sha;
                const { data: commit } = await github.rest.git.getCommit({
                  owner, repo,
                  commit_sha: parentCommitSha,
                });
                baseTreeSha = commit.tree.sha;
              } catch {
                parentCommitSha = null;
                baseTreeSha = null;
              }

              // 2. Create blobs for each screenshot
              const treeItems = [];
              for (const png of pngs) {
                const content = fs.readFileSync(png).toString('base64');
                const { data: blob } = await github.rest.git.createBlob({
                  owner, repo,
                  content,
                  encoding: 'base64',
                });
                const relPath = png.replace('web-app/test-results/', '');
                treeItems.push({
                  path: `${screenshotDir}/${relPath}`,
                  mode: '100644',
                  type: 'blob',
                  sha: blob.sha,
                });
              }

              // 3. Create a tree
              const treeParams = { owner, repo, tree: treeItems };
              if (baseTreeSha) treeParams.base_tree = baseTreeSha;
              const { data: tree } = await github.rest.git.createTree(treeParams);

              // 4. Create a commit
              const commitParams = {
                owner, repo,
                message: `UI test screenshots for PR #${prNumber} (run ${runId})`,
                tree: tree.sha,
              };
              if (parentCommitSha) commitParams.parents = [parentCommitSha];
              else commitParams.parents = [];
              const { data: newCommit } = await github.rest.git.createCommit(commitParams);

              // 5. Update or create the branch ref
              try {
                await github.rest.git.updateRef({
                  owner, repo,
                  ref: `heads/${screenshotBranch}`,
                  sha: newCommit.sha,
                });
              } catch {
                await github.rest.git.createRef({
                  owner, repo,
                  ref: `refs/heads/${screenshotBranch}`,
                  sha: newCommit.sha,
                });
              }

              // ── Build PR comment with embedded images & per-test emojis ──
              // Group screenshots by logical test name, merging all
              // projects (chromium, iphone-16) and retries together.
              const grouped = {};
              for (const png of pngs) {
                const relPath = png.replace('web-app/test-results/', '');
                const parts = relPath.split('/');
                const dirName = parts.slice(0, -1).join('/');
                const fileName = parts[parts.length - 1];

                // Parse project and retry from the directory name
                const retryMatch = dirName.match(/-retry(\d+)$/);
                const attempt = retryMatch ? parseInt(retryMatch[1], 10) + 1 : 1;
                const withoutRetry = retryMatch ? dirName.replace(/-retry\d+$/, '') : dirName;

                let project = 'chromium';
                let testKey = withoutRetry;
                if (withoutRetry.endsWith('-iphone-16')) {
                  project = 'iphone-16';
                  testKey = withoutRetry.replace(/-iphone-16$/, '');
                } else if (withoutRetry.endsWith('-chromium')) {
                  project = 'chromium';
                  testKey = withoutRetry.replace(/-chromium$/, '');
                }

                if (!grouped[testKey]) grouped[testKey] = [];
                grouped[testKey].push({ relPath, fileName, attempt, project, dirName: withoutRetry });
              }

              const rawBase = `https://raw.githubusercontent.com/${owner}/${repo}/${screenshotBranch}/${screenshotDir}`;

              for (const [testKey, files] of Object.entries(grouped)) {
                // Determine pass/fail from JSON results — passed if ALL
                // projects passed for this test
                const projects = [...new Set(files.map(f => `${testKey}-${f.project}`))];
                const statuses = projects.map(k => testStatusMap[k]);
                let emoji = ':grey_question:';
                if (statuses.length > 0 && statuses.every(s => s === 'passed')) emoji = ':white_check_mark:';
                else if (statuses.some(s => s === 'failed')) emoji = ':x:';

                const cleanName = testKey
                  .replace(/-/g, ' ')
                  .replace(/\b\w/g, c => c.toUpperCase());

                const totalScreenshots = files.length;
                const hasRetries = files.some(f => f.attempt > 1);
                const maxAttempt = Math.max(...files.map(f => f.attempt));
                const projectList = [...new Set(files.map(f => f.project))].sort();

                body += `### ${emoji} ${cleanName}\n\n`;
                body += `<details>\n<summary>Screenshots (${totalScreenshots})</summary>\n\n`;

                // Render each project's screenshots
                for (const proj of projectList) {
                  const projLabel = proj === 'iphone-16' ? 'iPhone 16' : 'Desktop';
                  const projFiles = files.filter(f => f.project === proj);

                  if (projectList.length > 1) {
                    body += `#### ${projLabel}\n\n`;
                  }

                  if (hasRetries) {
                    for (let a = 1; a <= maxAttempt; a++) {
                      const attemptFiles = projFiles.filter(f => f.attempt === a);
                      if (attemptFiles.length === 0) continue;
                      const label = a === 1 ? 'Initial attempt' : `Retry ${a - 1}`;
                      body += `**${label}**\n\n`;
                      for (const { relPath, fileName } of attemptFiles) {
                        const imgLabel = fileName.replace('.png', '').replace(/-/g, ' ');
                        body += `![${imgLabel}](${rawBase}/${relPath})\n\n`;
                      }
                    }
                  } else {
                    for (const { relPath, fileName } of projFiles) {
                      const imgLabel = fileName.replace('.png', '').replace(/-/g, ' ');
                      body += `![${imgLabel}](${rawBase}/${relPath})\n\n`;
                    }
                  }
                }

                body += `</details>\n\n`;
              }
            } else {
              body += `_No screenshots were captured._\n\n`;
            }

            // ── Find and update existing bot comment, or create a new one ──
            const { data: comments } = await github.rest.issues.listComments({
              owner, repo,
              issue_number: prNumber,
            });

            const existing = comments.find(c =>
              c.body?.includes('UI Test Screenshots')
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner, repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner, repo,
                issue_number: prNumber,
                body,
              });
            }

      # Fail the job if tests failed
      - name: Check test results
        if: steps.tests.outcome == 'failure'
        run: exit 1
